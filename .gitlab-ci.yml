# Define stages
stages:
  - unit-test
  - sonar-scan
  - build-non-prod
  - build-prd
  - image-scan

# For Unit test
test-job:
  stage: unit-test
  image: node:lts-alpine
  script:
    - npm ci
    - npm run test:ci
  artifacts:
    when: always
    paths:
      - coverage/junit.xml
    reports:
      junit: coverage/junit.xml
  rules:
    # Run on main and dev branches
    - if: $CI_COMMIT_BRANCH == "dev" 
  # Tags are used to select the runner that will execute the job
  # In this case it is a self-hosted runner with the tag "Project_Runner"
  tags:
    - VM_Runner

# For Code Scanning with SonarQube
sonarscanner-job:
  stage: sonar-scan
  image:
    name: sonarsource/sonar-scanner-cli:11
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
    GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
  cache:
    policy: pull-push
    key: "sonar-cache-$CI_COMMIT_REF_SLUG"
    paths:
      - "${SONAR_USER_HOME}/cache"
      - sonar-scanner/   
  # before_script:
  # - export SONAR_SCANNER_OPTS="-Xmx512m"
  script:
    - sonar-scanner
      -Dsonar.projectKey=Intern-Project
      -Dsonar.sources=.
      -Dsonar.host.url="${SONAR_HOST_URL}"
      -Dsonar.token="${SONAR_TOKEN}"
      -Dsonar.qualitygate.wait=true
      -Dsonar.projectVersion="${CI_COMMIT_SHORT_SHA}"
      -Dsonar.inclusions=src/*,test/*
      -Dsonar.javascript.node.maxspace=256
 
  rules:
  - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
  tags:
    - VM_Runner

# Template for Docker Builds
.docker-build:
  image: docker:24.0.5
  services:
    - name: docker:24.0.5-dind
      command: ["--host=tcp://0.0.0.0:2375", "--tls=false"]
  script:
    - docker login registry.gitlab.com -u $GITLAB_USERNAME -p $PAT_TOKEN
    - docker build -t registry.gitlab.com/testing382203/intern:$CI_COMMIT_TAG .
    - docker push registry.gitlab.com/testing382203/intern:$CI_COMMIT_TAG
  tags:
    - VM_Runner

# Non-Production Docker Build
build-job-non-prod:
  extends: .docker-build
  stage: build-non-prod
  rules:
    - if: $CI_COMMIT_TAG =~ /^dev-v\d+\.\d+\.\d+$/
    - if: $CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "dev"

# Production Docker Build
build-job-prd:
  extends: .docker-build
  stage: build-prd
  rules:
    - if: $CI_COMMIT_TAG =~ /^prd-v\d+\.\d+\.\d+$/

# For Container Scanning with Trivy
image_scan:
  stage: image-scan
  image:
    name: docker.io/aquasec/trivy:latest
    # Entrypoint allows to override the default entrypoint of the image. From "trivy trivy --version" -> To "trivy --version" 
    entrypoint: [""]
  variables:
    GIT_STRATEGY: none
    # Gitlab registry login
    TRIVY_USERNAME: "$GITLAB_USERNAME"
    TRIVY_PASSWORD: "$PAT_TOKEN"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG
  script:
    - trivy --version
    # update vulnerabilities db
    - time trivy image --download-db-only
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    # - time trivy image --exit-code 0 --format template --template "@/contrib/gitlab.tpl"
    #     --output "$CI_PROJECT_DIR/gl-container-scanning-report.json" "$FULL_IMAGE_NAME"
    - trivy image --format json --output gl-container-scanning-report.json "$FULL_IMAGE_NAME"

    # Prints full report
    - time trivy image --exit-code 0 "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - time trivy image --exit-code 1 --severity CRITICAL "$FULL_IMAGE_NAME"
  rules:
  - if: $CI_COMMIT_TAG =~ /^prd-v\d+\.\d+\.\d+$/
  # - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  tags:
    - VM_Runner


